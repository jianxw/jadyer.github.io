<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 当前POM模型的版本：目前其值只能是固定的4.0.0 -->
    <modelVersion>4.0.0</modelVersion>

    <!-- 这三个属性:groupId、artifactId、version即为项目的坐标，简称GAV -->
    <!-- 项目的名称 -->
    <groupId>com.jadyer.blog</groupId>

    <!-- 项目的模块名称。建议用"项目名称-模块名称"。按照Maven的约定，此时Java类的包名就应该是com.jadyer.blog.dao -->
    <!-- 即通常项目中Java类包都应该基于项目的groupId和artifactId。虽然这不是必须的，但这些显然更加清晰、更加符合逻辑 -->
    <artifactId>blog-dao</artifactId>

    <!-- 项目的版本名称 -->
    <version>0.0.1.Release</version>

    <!-- 打包类型：不设置的话，默认即为jar -->
    <packaging>jar</packaging>

    <!-- 用于声明一个对于用户而言更为友好的项目名称 -->
    <name>玄玉的手工博客系统之DAO模块</name>

    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>4.10</junit.version>
        <mysql.driver.version>5.1.18</mysql.driver.version>
        <maven-source-plugin.version>2.1.2</maven-source-plugin.version>
        <maven-rar-plugin.version>2.2</maven-rar-plugin.version>
        <maven-shade-plugin.version>1.6</maven-shade-plugin.version>
        <maven-compiler-plugin.version>3.1</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>2.14.1</maven-surefire-plugin.version>
        <sql-maven-plugin.version>1.5</sql-maven-plugin.version>
        <mysql.driver>com.mysql.jdbc.Driver</mysql.driver>
        <mysql.url>jdbc:mysql://127.0.0.1:3306/jadyer?characterEncoding=UTF-8</mysql.url>
        <mysql.username>root</mysql.username>
        <mysql.password>hongyu</mysql.password>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>${junit.version}</version>
            <!-- 依赖的范围:默认为compile -->
            <!--     test:测试范围有效。即编译和打包时不会加入该依赖包 -->
            <!--  compile:编译范围有效。即编译和打包时会将该依赖包一并加入 -->
            <!-- provided:编译和测试时有效，最后生成war包时不会加入该依赖包。比如web容器本身已包含的servlet-api.jar，再打包则会冲突 -->
            <!--  runtime:运行范围有效，编译时则不依赖 -->
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.driver.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- maven-source-plugin插件:打包项目源码 -->
            <!-- Run As Maven build : clean package -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>${maven-source-plugin.version}</version>
                <executions>
                    <execution>
                        <!-- 绑定在哪个周期。这里设定为package后绑定，即package后再运行maven-source-plugin插件 -->
                        <!-- 注:maven生命周期中，package阶段负责接受编译好的代码并打包成可发布的格式，如JAR -->
                        <phase>package</phase>
                        <!-- 所要运行maven-source-plugin插件的目标 -->
                        <goals>
                            <goal>jar-no-fork</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <!-- 将之打成rar压缩包 -->
            <!-- Run As Maven build : clean package -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-rar-plugin</artifactId>
                <version>${maven-rar-plugin.version}</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>rar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <!-- 默认打包生成的jar是不能够直接运行的，因为带有main()方法的类信息不会被添加到manifest中 -->
            <!-- 为了生成可执行的jar文件，我们需要借助maven-shade-plugin插件，其配置信息如下 -->
            <!-- Run As Maven build : clean package -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>${maven-shade-plugin.version}</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <!-- 配置<mainClass>为带有main()方法类。如此，项目在打包时就会将该信息放到/META-INF/MANIFEST.MF文件中 -->
                                    <!-- 构建完成后target目录会发现blog-dao-0.0.1.Release.jar和original-blog-dao-0.0.1.Release.jar -->
                                    <!-- 前者是带有Main-Class信息的可运行的jar，后者是原始的jar。然后我们到CMD窗口中切换到项目根目录中执行该jar -->
                                    <!-- D:\Develop\MyWorkspace\MavenStudy>java -jar target\blog-dao-0.0.1.Release.jar -->
                                    <mainClass>com.jadyer.util.ManiFestTest</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <!-- 指明源码编译级别 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
            <!-- 指明测试类的运行情况 -->
            <!-- Run As Maven build : clean package -->
            <!-- 可能是由于历史的原因，Maven2/3中用于执行测试的插件不是maven-test-plugin，而是maven-surefire-plugin -->
            <!-- 如果没有使用该插件，Maven默认会执行符合约定格式的测试类(即以Test开头或结尾、或者以TestCase结尾的Java类) -->
            <!-- 然而我们想跳过测试，或者排除某些测试类，或者使用一些TestNG特性的时候，该插件就很有必要了 -->
            <!-- 也可以执行Run As Maven build : clean package -Dtest=FooTest，其效果是仅运行FooTest测试类 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <!-- 设置包含的测试类 -->
                    <includes>
                        <include>**/MyTest*</include>
                    </includes>
                    <!-- 设置不进行测试的类 -->
                    <excludes>
                        <exclude>Test*</exclude>
                    </excludes>
                    <!-- 跳过测试阶段，并且也不会编译测试类。若仅仅想跳过测试并编译测试类，则可用<skipTests>标签 -->
                    <!-- <skip>true</skip> -->
                </configuration>
            </plugin>
            <!-- 生成测试报告(我们可以在生成的报告中轻松查看测试覆盖率等等) -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>cobertura-maven-plugin</artifactId>
                <configuration>
                    <formats>
                        <format>html</format>
                        <format>xml</format>
                    </formats>
                </configuration>
                <executions>
                    <execution>
                        <id>cobertura-report</id>
                        <!-- 测试完成后就生成测试报告 -->
                        <phase>test</phase>
                        <goals>
                            <goal>cobertura</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <!-- 通过Maven来执行配置好的数据库脚本。可以在POM中配置sql命令，或将脚本写在文件中并在POM中配置文件位置 -->
            <!-- 最后，在CMD窗口中运行mvn sql:execute以执行所有脚本，或者在MyEclipse中Run As Maven build:clean package -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>sql-maven-plugin</artifactId>
                <version>${sql-maven-plugin.version}</version>
                <!-- 这是针对该插件的依赖包 -->
                <dependencies>
                    <dependency>
                        <groupId>mysql</groupId>
                        <artifactId>mysql-connector-java</artifactId>
                        <version>${mysql.driver.version}</version>
                    </dependency>
                </dependencies>
                <configuration>
                    <driver>${mysql.driver}</driver>
                    <url>${mysql.url}</url>
                    <username>${mysql.username}</username>
                    <password>${mysql.password}</password>
                    <!-- 该插件连接数据库成功后，所要运行的命令 -->
                    <sqlCommand>create database IF NOT EXISTS jadyer_maven</sqlCommand>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>execute</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>